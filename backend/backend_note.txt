bookmarker project + browser extension:
quickly bookmark any page
(free version) -> only bookmarks + extension
(paid version) -> bookmarks + folders + categories + 
    bookmark includes account (email, username, password encrypted), + note + sharing + 
    csv export and import + export to browser, import from browser +
    page is up test (status code check)
    
Saving tokens in localStorage is not a secure.

1. basic setup:
    pip install django djangorestframework
    pip install django-cors-headers
    django-admin startproject server .
    add rest_framework, corsheaders to INSTALLED_APPS
    python manage.py startapp accounts
    add accounts to INSTALLED_APPS (local apps go lowest)
    pip install django-environ
    pip install djangorestframework-simplejwt

2. environment variables:
    import django-environ
    create an env instance
    add default debug value to that instance
    create a .env file next to server folder
    make env instance to read from that file
    move secet_key and debug to .env file
    update settings.py (secet_key and debug) to read from env instance

3. add configs:
    add cors headers middleware to MIDDLEWARES above common middleware or whitenoise
    add REST_FRAMEWORK config to settings.py
    add SIMPLE_JWT to settings.py (configs for tokens)

4. custom user model
    add custom user model to accounts (should be called CustomUser to avoid conflict)
    add OTP model to accounts (could be added later as well)
    update/add AUTH_USER_MODEL to settings.py
    add UserManager to managers.py in accounts
    add CustomUser to admin.py in accounts
    make and apply migrations
    python manage.py makemigrations (optional: accounts)
    python manage.py migrate
    create superuser: admin@example.com-Arman-Karimi-shit123*
    python manage.py createsuperuser
    add tests

5. adding auth routes (register and verifyEmail):
    added register serializer
    add register view
    added a url path for register
    requires utils (send_otp_to_user and generate_otp) (not working-email not sending) (fixed)
    email backend needed to be set in settings.py (set to console backend)
    testuser01@gmail.com-Nick-Tole-home123* UPDATE PASSWORD using reset password feature: home123
    adding email verification view
    email verification serializer that only has one field (otp)
    adding url (ok)

6. configuring CORS:
    corsheaders must exist in INSTALLED_APPS
    add CORS_ALLOWED_ORIGINS and  CSRF_TRUSTED_ORIGINS to settings.py

7. adding login:
    add login serializer
    add login view to accounts/views.py
    login serializer uses RefreshToken from djangorestframework_simplejwt to generate...
    access token and refresh token for user (it is a method in CustomUser model)
    this requires installation of djangorestframework_simplejwt (if not installed yet)
    also SIMPLE_JWT and REST_FRAMEWORK (authentication class) config must exist in settings.py
    add url for login
    test the login with testuser01@gmail.com-Nick-Tole-home123*
    test was successful, email, full_name, access and refresh token were returned

8. add test view (accessible to logged in users only)
    (i previously tested this using httpie, now use frontend)
    add test view (test this in frontend)

9. added a post test request in api (ok)
10. logout needs to be added
    add rest_framework_simplejwt.token_blacklist to isntalled_apps
    run migrations

11. IMPORTANT: Adding basic and session authentication from official docs:
(ALONGSIDE current jwt authentication)
(to be used with browsable api only)

user's bookmark list no option to add bookmarks. fixed.
deleting the old ones, (for user testuser01)
adding 10 actual bookmarks.
problem 01: user should not be able to choose the owner in listcreate api view. [FIXED]
problem 02: bookmark item title max length too short. [FIXED]

12. Adding pagination to bookmarer
    add pagination config to settings.py (add to REST_FRAMEWORK config)
    done, but console gets a small warning about pagination
    warning in pagination: unordererd list, pagination may yield inconsistent results
    
13. Upgrading bookmarks list view from listcreate api to listcreatedestroy api
    there is not such generic view
    trying to utilize viewset + router
    in viewset views, we can use action decorator to create a multiple delete items action by setting detail to false

14. according to some docs and notes online, deleting multiple objects is not a good idea
    in restful design, since delete http verb should be used with one object only
    but we can use a post request to collect a multiple ids from request body
    then perform the delete in backend.

15. csv export is done in frontend, for csv import some backend code is required.
    i want to get the file, read its data, and not store it in database or filesystem

16. added password reset feature
    main authentication app: accounts
    backup authentication app (education purposes only)
    PROBLEM: token validation not working, i think the problem is with "AuthenticationFailed"


17. parsers and renderers:
    (i will apply this to accounts app)
    parsers: allows to accept requests with various media types
    renderers: allows to return responses with various media types

    all views perform content-negotiation:
    1. examine the request 'Accept' header to determine which media type to expect in response
    2. format suffixes may be used for this

    1. setting the renderer
    can be done global level or per-view level, done in accounts>api>views
    TemplateHTMLRenderer no need for serialzier.
    serializer can be used, but data will need to be wrapped in a dict
    should use a template_name
    
    You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, 
    or to return both HTML and API responses from a single endpoint.

    project structure update:
        apps will have three type of views, regular views that will render html templates and 
        api views. api views will have two type of views, with json responses, and with html responses
        (using parsers, renderers, and content negotiation)
        each app will have only one urls.py file.
    
    in order to understand the entire django testing topics, i will implement regular html views as well
    installed django crispy forms (no template pack)
    also do not forget to add template caching to entire django project and django crispy forms
    django-crispy-forms uses something called FormHelpers

    to add authentication: 
    there are two common ways: django's built-in auth, or django-allauth package
    i will implement both, in separate urls

    1. explicitly specify authentication backend

    builtin UserCreationForm and UserChangeForm cannot be used with our CustomUser model, no username field
    unless exclude is used to remove username field

    IMPORTANT: use function based views for html responses with api
    and class-based views for regular views in views/views.py

    three authentication methods:
    basic authentication (every time a request is made, auth headers must be sent - NOT USED)
    tokens (using jwt - currently django rest framework uses this)
    sessions and cookies (our html views in accounts app uses this)

    next url upon successful login added successfully
    
    problem in forms>EmailChangeForm (nope, validate_email works fine html forms)

    for change email view, in both html and json response views...
    validate_email always returns false, for some reason.
    i checked the same email address to register a new user, and it was fine.











authentication note:
permission and throttling policies can use credentials to determine if request should be permitted.

request.user -> contrib.auth's -> User class

request.auth

Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.

(NOTE: this topic is closely related to permissions)

The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.

if no class authenticates, request.user = django.contrib.auth.models.AnonymousUser
and request.auth = None

authentication schemes can be set in DEFAULT_AUTHENTICATION_CLASSES setting (globally) or per-view using authentication_classes.

to add login to browsable api:
    add the following path to project level urls.py
    path('api-auth/', include('rest_framework.urls')),



logger app:
signals can be used to implement a sort of logging system
e.g. accounts app can send a signal every time a user registers